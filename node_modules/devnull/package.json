{
  "name": "devnull",
  "version": "0.0.9",
  "description": "A simple logger with automatic function detection.",
  "homepage": "http://observer.no.de",
  "keywords": [
    "log",
    "logger",
    "logging",
    "dev/null"
  ],
  "author": {
    "name": "Arnout Kazemier",
    "email": "arnout@observe.it"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/observing/devnull.git"
  },
  "dependencies": {
    "colors": "0.6.0-1"
  },
  "devDependencies": {
    "mocha": "*",
    "should": "0.3.2",
    "long-stack-traces": "0.1.2",
    "mongodb": "0.9.9-8"
  },
  "main": "index",
  "scripts": {
    "test": "make test"
  },
  "readme": "# dev/null because logging to dev/null is webscale\n\nCurrent build status: [![BuildStatus](https://secure.travis-ci.org/observing/devnull.png)](http://travis-ci.org/observing/devnull)\n\n### Introduction\n\n**devnull** is an feature rich logging library for Node.js. It was designed from the ground up to assist you during development and be powerful in production. It works just like the regular `console.log` statements you have in code, it uses the same formatter for logging to the terminal and has the same API. It's basically a cherry on the top :).\n\n### Namespacing\n\nThe module automatically adds intelligent namespaces to all your log calls so you can easily track back those log statements in your code without having to remember where you placed them.\n\n### Evented\n\nThe logger is build on top of the EventEmitter prototype. This allows you to handle all critical log messages in one central location. You might want to be notified when you application starts emitting critical errors. I know I would.\n\n### Multiple transports\n\nIt supports different logging transports. You might want to log to the terminal in production but to MongoDB in production so you have a centralized location of all your logs. Each logger can have multiple transports.\n\n![output preview](http://f.cl.ly/items/2t461h193a2D1t0f0k0q/Screen%20Shot%202011-12-15%20at%2022.29.14.PNG)\n\nThe image above is the result of the [example/logging.js](https://github.com/observing/devnull/blob/master/example/logging.js)\n\n## Installation\n\nThe module is tested against Node.js 0.4 and 0.6 and can be installed using the Node.js Package Manager, also known as NPM.\n\n```\nnpm install devnull\n```\n\nIf you don't have NPM installed on your system you can get it at [http://npmjs.org](http://npmjs.org)\n\n## API\n\n### Initializing your logger\n\nYou can either initialize the default logger:\n\n```js\nvar Logger = require('devnull')\n  , logger = new Logger\n\nlogger.log('hello world')\nlogger.info('pew pew')\nlogger.error('oh noes, something goes terribly wrong')\n```\n\nOr configure a customized instance using the options argument:\n\n```js\nvar Logger = require('devnull')\n  , logger = new Logger({ timestamp: false })\n\nlogger.log('hello world')\n...\n```\n\nThe following options are available for configuring your customized instance:\n\n- **env** either development of production. Default is based on the isAtty check of the process.stdout.\n- **level** Only log statements that are less than this level will be logged. This allows you to filter out debug and log statements in production for example. Default is 8.\n- **notification** At what log level should we start emitting events? Default is 1.\n- **namespacing** At what log level should we start generating namespaces (uses callsite based stacktraces)? Defaults to 8.\n- **timestamp** Should we prepend a timestamp to the log message? Logging is always done asynchronously so it might be that log messages do not appear in order. A timestamp helps you identify the order of the logs. Default is true.\n- **pattern** The pattern for the timestamp. Everybody prefers it's own pattern. The pattern is based around the great [140bytes date entry](https://gist.github.com/1005948) but also allows functions to be called directly. Default is the util.log format that Node.js adopted.\n- **base** Should the logger be configured with the base transport (log to process.stdout)? Default is true.\n\n### .configure(env, fn)\n\nConfigure the module for different environments, it follows the same API as Express.js.\n\n#### Arguments\n\n_env_ (string) environment\n_fn_ (function) callback\n\n#### Example\n\n```js\nvar Logger = require('devnull')\n  , logger = new Logger\n\n// runs always\nlogger.configure(function () {\n  logger.log('running on the things')\n})\n\n// only runs in production\nlogger.configure('production', function () {\n  logger.log('running in production')\n})\n\nlogger.configure('development', function () {\n  logger.log('running in development')\n})\n```\n\n### .use(Transport, options)\n\nAdds another transport to the logger. We currently ship 2 different transports inside the module (stream and mongodb).\n\nThese transports can be required using `require('devnull/transports/<transportname>')`.\n\n#### Arguments\n\n_Transport_ (Transport) a uninitialized transport instance.\n_options_ (object) options for the transport.\n\n#### Example\n\n```js\nvar Logger = require('devnull')\n  , logger = new Logger\n\n// use the stream transport to log to a node.js stream\nlogger.use(require('devnull/transports/stream'), {\n    stream: require('fs').createWriteStream('logger.log')\n})\n\n// also exports all transports :)\nvar transport = require('devnull/transports')\n\n// and add mongodb to production logging\nlogger.configure('production', function () {\n  logger.use(transport.mongodb, {\n      url: 'mongodb://test:test@localhost:27017/myapp'\n  })\n})\n\nlogger.warning('hello world')\n```\n\n### .remove(Transport)\n\nRemoves all transports of that instance.\n\n#### Arguments\n\n_Transport_ (Transport) a transport\n\n#### Example\n\n```js\nvar Logger = require('devnull')\n  , logger = new Logger({ base: false })\n  , transports = require('devnull/transports')\n\nlogger.use(transports.stream)\nlogger.remove(transports.stream)\n```\n\n### .on(Event, fn)\n\nBecause the Logger is build upon the EventEmitter you can also start listening for log messages. This is set to warning levels by default in the configuration options. In addition to listening to the log message you can also listen to the events of the transports. These are prefixed with `transport:`. The following events are emitted:\n\n- All the types (alert, critical etc)\n\nAnd the transport events:\n\n- `transport:failed(err)` transport failed to initialize\n- `transport:error(err, log)` transport failed to write the log due to an error\n- `transport:write(log)` transport written the log message\n\n#### Arguments\n\n_event_ (string) event to listen for\n_fn_ (function) callback, receives _args_ (array), _stack_ (stack/callsite)\n\n#### Example\n\n```\nvar Logger = require('devnull')\n  , logger = new Logger\n  \nlogger.on('error', function (args, stack) {\n // args = foo bar, 1\n // stack = stack trace that we used to generate the namespace\n email('errors@pew.pew', 'error!', args);\n})\n\nlogger.error('foo bar', 1)\n```\n\n### .ignore(file)\n\nIgnore the output of a given file name, so everything that is logged in that\nfile is ignored.\n\n#### Arguments\n\n_env_ (string) file\n\n#### Example\n\n```js\nvar Logger = require('devnull')\n  , logger = new Logger\n\nlogger.ignore('my_other_module.js');\n```\n\n### .unignore(file)\n\nUnignore the file that you ignored above\n\n#### Arguments\n\n_env_ (string) file\n\n#### Example\n\n```js\nvar Logger = require('devnull')\n  , logger = new Logger\n\nlogger.ignore('my_other_module.js');\nlogger.unignore('my_other_module.js');\n```\n\n### Logging methods and levels\n\nThe logger has the following methods available for logging. The (<number>) is the log level.\n\n- alert (0)\n- critical (1)\n- error (2)\n- warning (3)\n- metric (4)\n- notice (5)\n- info (6)\n- log (7)\n- debug (8)\n",
  "readmeFilename": "readme.md",
  "_id": "devnull@0.0.9",
  "dist": {
    "shasum": "774745df07b11ea58b4151aba40c01706cb70525"
  },
  "_from": "devnull"
}
